# -*- coding: utf-8 -*-
"""Projeto1_C012.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cdQzlQwAoiTz-0G5O3GeIHVS6Ej_qd4y
"""

"""Alunas: Clara Azevedo-GEC-1897; Maria Eduarda de Oliveira-GEC-1896; Vitória Dutra-GES-414"""

import threading
import random

class Player(threading.Thread):
    def __init__(self, player_id, name):
        """Inicializa um jogador com um ID e um nome."""
        super().__init__()
        self.player_id = player_id
        self.name = name
        self.choice = None
        self.opponent = None

    def make_choice(self):
        """Faz uma escolha aleatória entre 'pedra', 'papel' e 'tesoura'."""
        self.choice = random.choice(['pedra', 'papel', 'tesoura'])
        print(f'{self.name} escolheu {self.choice}')

    def run(self):
        """Método que será executado quando a thread for iniciada."""
        if self.opponent:
            self.make_choice()
            self.opponent.make_choice()

    def play_even_odd(self):
        """Joga par ou ímpar com outro jogador."""
        choice = random.choice(['par', 'ímpar'])
        number = random.randint(1, 10)
        print(f'{self.name} escolheu {choice} e jogou o número {number}')
        return choice, number

import threading
import random
import time

class Player(threading.Thread):
    def __init__(self, name, opponent, winners_list, lock):
        super().__init__()
        self.name = name
        self.opponent = opponent
        self.choice = None
        self.winners_list = winners_list
        self.lock = lock

    def make_choice(self):
        time.sleep(random.uniform(0.1, 0.4))  # Simula execução paralela
        self.choice = random.choice(['pedra', 'papel', 'tesoura'])
        print(f'{self.name} escolheu {self.choice}')

    def play_even_odd(self):
        time.sleep(random.uniform(0.1, 0.4))
        choice = random.choice(['par', 'ímpar'])
        number = random.randint(1, 10)
        print(f'{self.name} escolheu {choice} e jogou {number}')
        return choice, number

    def run(self):
        self.make_choice()
        self.opponent.make_choice()

        winner = None
        if self.choice == self.opponent.choice:
            print(f'{self.name} empatou com {self.opponent.name}, disputarão Par ou Ímpar!')
            choice1, number1 = self.play_even_odd()
            choice2, number2 = self.opponent.play_even_odd()
            total = number1 + number2
            result = 'par' if total % 2 == 0 else 'ímpar'
            if choice1 == result:
                winner = self.name
            else:
                winner = self.opponent.name
        else:
            if (self.choice == 'pedra' and self.opponent.choice == 'tesoura') or \
               (self.choice == 'papel' and self.opponent.choice == 'pedra') or \
               (self.choice == 'tesoura' and self.opponent.choice == 'papel'):
                winner = self.name
            else:
                winner = self.opponent.name

        print(f'{winner} venceu a rodada!')

        # Adiciona vencedor de forma segura (evita problemas com concorrência)
        with self.lock:
            self.winners_list.append(winner)

def main():
    player_names = ['Alice', 'Joao', 'Carla', 'Davi', 'Eva', 'Lucas', 'Julia', 'Marcos']

    round_num = 1
    while len(player_names) > 1:
        print(f'\n--- Rodada {round_num} ---')
        print(f'Jogadores atuais: {player_names}')

        winners = []
        lock = threading.Lock()
        threads = []
        player_pairs = [] # Armazena os pares de jogadores

        # Embaralha para variar os confrontos
        random.shuffle(player_names)

        # Cria as threads para cada par de jogadores
        for i in range(0, len(player_names) - 1, 2):
            p1_name = player_names[i]
            p2_name = player_names[i+1]

            player1 = Player(p1_name, None, winners, lock)
            player2 = Player(p2_name, player1, winners, lock)
            player1.opponent = player2

            threads.append(player1)
            threads.append(player2)
            player_pairs.append((p1_name, p2_name)) # Adiciona o par à lista

        # Inicia todas as threads
        for t in threads:
            t.start()
        for t in threads:
            t.join()

        # Atualiza a lista de jogadores com os vencedores da rodada, mantendo a ordem correta
        new_player_names = []
        for pair in player_pairs:
            if pair[0] in winners:
                new_player_names.append(pair[0])
            else:
                new_player_names.append(pair[1])
        player_names = new_player_names
        round_num += 1

    print(f'\n {player_names[0]} venceu!')
    input('Pressione Enter para encerrar...')

if __name__ == '__main__':
    main()